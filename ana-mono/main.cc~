#include <complex>
#include <array>
#include <iostream>
#include <fstream>
#include "../parameters.h"

#define complex std::complex<double>
const complex I = complex(0., 1.);

using namespace parameters;

complex bCoef (int n, double t) {
  complex bn;
  switch (n) {
   case 1: // -(2n + 1) = -3
    bn = exp (2.*I*t) * (2 + t*t - 2*cos (t) + 2 * t * sin (t)) / (8*t*t);
    break;
   case 0: // -(2n + 1) = -1
    bn = exp (-t*I) * (
      -1. + I*t - exp (2.*I*t) * (
        5. + I*t + (t*t-6) * cos (t) + I * (2.+t*(t-4.*I)) * sin (t))) / (8*t*t);
    break;
   case -1:  // -(2n + 1) = 1
    bn = exp (-2.*I*t) * (
      2. - exp (3.*I*t) * (I*t+1.) + exp (2.*I*t) * (4.+2.*I*t) - 2.*I*t - t*t
      + I * exp (I*t) * (5.*I + t)) / (8*t*t);
    break;
   case -2:  // -(2n + 1) = 3
    bn = exp (-2.*I*t) * (2 + t*t - 2*cos (t) + 2 * t * sin (t)) / (8*t*t);
    break;
   default:
    std::cerr << "undefined M in bCoef!!!" << std::endl;
  }
  return bn;
}

complex integrand (int K, int M, double tau) {
  const double eps = 0.01;
  auto diffuseCoef = pow (M_PI / (eps + 0.5 * I * (tau)), 1.5);
  auto F0 = (Up + Ip) * tau - 2 * Up * (1. - cos (tau)) / tau;
  F0 /= w0;
  double C0 = sin (tau) - 4 * sin (0.5*tau) * sin (0.5*tau) / tau;
  C0 /= w0;
  complex result = diffuseCoef;
  result *= bCoef (K-M, tau);
  result *= exp (- I * F0);
  result *= pow (I, M);
  result *= C0 > 0. ? // some trick to invoke the library function
    std::cyl_bessel_j (double(M), Up * C0) :
    - std::cyl_bessel_j (double(M), -Up * C0);
  result *= exp (I * double(M) * tau);
  return result;
}


int main (int argc, char* argv[]) {

  std::ofstream outfile ("res.dat");
  const long nt = 4000;
  auto dt = 20 * 3.14 / (nt - 1.);

  // n = K - M
  // std::array<int, 1> n_set = { 0 };
  std::array<int, 4> n_set = {-2, -1, 0, 1};
  // std::array<int, 4> n_set = {-3, -1, 1, 3};

  for (int K = 5; K < 50; K ++) {
    complex s = 0.;
    for (auto n : n_set) {
      for (long it = 0; it < nt; it ++) {
        auto tau = it * dt;
        auto M = K - n;
        auto res = integrand (K, M, tau);
        if (std::isnan (real (res))) res = 0.;
        // if (it == 0 || it == nt - 1) res *= 0.5;
        s += res;
        // outfile << tau << " "<< real (conj (res) * res) << std::endl;
      }
    }
    s *= I * dt;
    outfile << 2*K+1 << " " << real (conj (s) * s) << std::endl;
  }


  // std::cout << bCoef (-3, 100.) << " " << bCoef (3, 100.) << std::endl;


  outfile.close ();
  // std::cout << integrand (30, 31, 50.) << std::endl;


  // std::cout << std::cyl_bessel_j (30, -5.2) << std::endl;
  return 0;

}
